<!DOCTYPE html>
<%
var rowsCount = 5;
var columnsCount = 9;
var cellSize = 50;
%>
<html>
  <head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <script type="text/javascript" src="/javascripts/jquery.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function(){
            var EMPTY_NAME = '空';

            var camper = {
                RED: 'red',
                BLACK: 'black',
                assignCamp: function (firstCamp, player1, player2) {
                    if (firstCamp == this.RED) {
                        player1.camp = firstCamp;
                        player2.camp = this.BLACK;
                    } else if (firstCamp == this.BLACK) {
                        player1.camp = firstCamp;
                        player2.camp = this.RED;
                    }
                },
                getEnemy: function(allyCamp) {
                    if (allyCamp == this.RED) {
                        return this.BLACK;
                    } else if (allyCamp == this.BLACK) {
                        return this.RED;
                    }
                }
            }

            var rowsCount = <%=rowsCount%>;
            var columnsCount = <%=columnsCount%>;
            var cellSize = <%=cellSize%>;
            var board = [];
            var deadPieces = [];

            function Piece(name, camp, x, y, cbMoveTo) {
                this.name = name;
                this.camp = camp;
                this.x = x;
                this.y = y;
                this.hidden = true;
                this.canMoveTo = cbMoveTo;

                function replaceTarget(target, source) {
                    target.name = source.name;
                    target.camp = source.camp;
                    target.canMoveTo = source.canMoveTo;

                    source.name = EMPTY_NAME;
                    source.camp = undefined;
                    source.canMoveTo = undefined;
                }

                this.moveTo = function(anotherPiece) {
                    if (anotherPiece.name == EMPTY_NAME) {
                        replaceTarget(anotherPiece, this);
                    }else {
                        deadPieces.push(Piece(anotherPiece.name, anotherPiece.camp,
                            anotherPiece.x, anotherPiece.y, anotherPiece.cbMoveTo));
                        replaceTarget(anotherPiece, this);
                    }
                };
            }

            function createEmptyPieceAt(x, y) {
                var p = new Piece(EMPTY_NAME, undefined, x, y, undefined);
                p.hidden = false;
                return p;
            }

            function randomInt(upLimit) {
                return Math.round(Math.random() * 100) % upLimit;
            }

            function isInStraightLine(p1, p2) {
                return (p1.x == p2.x && p1.y != p2.y) || (p1.x != p2.x && p1.y == p2.y);
            }

            function obstaclesCountOnStraightLine(p1, p2) {
                var count = 0;
                if (p1.x == p2.x && p1.y != p2.y) {
                    var upLimit = p1.y;
                    var lowLimit = p2.y;
                    if (upLimit < lowLimit) {
                        upLimit = p2.y;
                        lowLimit = p1.y;
                    }
                    for (var i = lowLimit + 1; i < upLimit; i++) {
                        if (board[i][p1.x].name != EMPTY_NAME) {
                            count++;
                        }
                    }
                } else {
                    var upLimit = p1.x;
                    var lowLimit = p2.x;
                    if (upLimit < lowLimit) {
                        upLimit = p2.x;
                        lowLimit = p1.x;
                    }
                    for (var i = lowLimit + 1; i < upLimit; i++) {
                        if (board[p1.y][i].name != EMPTY_NAME) {
                            count++;
                        }
                    }
                }
                return count;
            }

            var piecesDesc = {
                '车': {count:2, cbMoveTo:function(piece){
                    return isInStraightLine(this, piece) && obstaclesCountOnStraightLine(this, piece) == 0;
                 }},
                '马': {count:2, cbMoveTo:function(piece){
                    var dx = Math.abs(this.x - piece.x);
                    var dy = Math.abs(this.y - piece.y);
                    return (dx == 1 && dy == 2 && board[(this.y + piece.y) / 2][this.x].name == EMPTY_NAME) ||
                        (dx == 2 && dy == 1 && board[this.y][(this.x + piece.x) / 2].name == EMPTY_NAME);
                }},
                '相': {count:2, cbMoveTo:function(piece){
                    return Math.abs(this.x - piece.x) == 2 && Math.abs(this.y - piece.y) == 2 &&
                        board[(this.y + piece.y) / 2][(this.x + piece.x) / 2].name == EMPTY_NAME;
                }},
                '士': {count:2, cbMoveTo:function(piece){
                    return Math.abs(this.x - piece.x) == 1 && Math.abs(this.y - piece.y) == 1;
                }},
                '炮': {count:2, cbMoveTo:function(piece){
                    if (isInStraightLine(this, piece)) {
                        var count = obstaclesCountOnStraightLine(this, piece);
                        return (piece.camp == undefined && count == 0) || count == 1;
                    }
                    return false;
                }},
                '将': {count:1, cbMoveTo:function(piece){
                    var dx = Math.abs(this.x - piece.x);
                    var dy = Math.abs(this.y - piece.y);
                    return (dx == 1 && (dy == 1 || dy == 0)) || (dx == 0 && dy == 1);
                }},
                '兵': {count:5, cbMoveTo:function(piece){
                    var dx = Math.abs(this.x - piece.x);
                    var dy = Math.abs(this.y - piece.y);
                    return (dx == 1 && dy == 0) || (dx == 0 && dy == 1);
                }}
            };
            var availablePieces = [];
            function createPiece(camp, name, desc) {
                for (var i = 0; i < desc.count; i++) {
                    availablePieces.push({camp: camp, name: name, cb: desc.cbMoveTo});
                }
            }
            function createPiecesFor(camp) {
                Object.keys(piecesDesc).forEach(function(o){
                    createPiece(camp, o, piecesDesc[o]);
                });
            }
            createPiecesFor(camper.RED);
            createPiecesFor(camper.BLACK);

            function popAPieceTo(x, y) {
                if (availablePieces.length > 0) {
                    var piece = undefined;
                    if (availablePieces.length == 1) {
                        piece = availablePieces[0];
                    } else {
                        piece = availablePieces.splice(randomInt(availablePieces.length), 1)[0];
                    }
                    return new Piece(piece.name, piece.camp, x, y, piece.cb);
                } else {
                    return createEmptyPieceAt(x, y);
                }
            }

            var emptyColumn = Math.floor(columnsCount / 2);
            var emptyRow = rowsCount - 1;
            for (var i = 0; i < rowsCount; i++) {
                board.push([]);
                if (i == emptyRow) {
                    for (var j = 0; j < columnsCount; j++) {
                        board[i].push(createEmptyPieceAt(j, i));
                    }
                } else {

                    for (var j = 0; j < columnsCount; j++) {
                        if (j == emptyColumn) {
                            board[i].push(createEmptyPieceAt(j, i));
                        } else {
                            board[i].push(popAPieceTo(j, i));
                        }
                    }
                }
            }

            function getCellFromMami(jqMami) {
                var x = jqMami.css('left');
                var y = jqMami.css('top');
                x = x.substring(0, x.length - 2) / cellSize;
                y = y.substring(0, y.length - 2) / cellSize;
                return board[y][x];
            }

            function updateMamiForCell(jqMami, cell) {
                if (cell.hidden) {
                    return;
                } else {
                    jqMami.addClass('discovered');
                }
                if (cell.name == EMPTY_NAME) {
                    jqMami.removeClass('red discovered selected').addClass('discovered empty').text('');
                } else {
                    jqMami.removeClass('red black').text(cell.name);
                    if (cell.camp == camper.RED) {
                        jqMami.addClass(camper.RED);
                    } else {
                        jqMami.addClass(camper.BLACK);
                    }
                }
            }

            // AIPlayer 的难度依据 AI 是否知晓盘面全局（未翻开的棋子）划分。
            var aiPlayer = {
                camp: undefined,
                testCouldMove: function(pieceMami, targetMami) {
                    var piece = getCellFromMami(pieceMami);
                    var target = getCellFromMami(targetMami);
                    return piece.canMoveTo(targetMami);
                },
                play: function() {
                    // 电脑检测有无已翻开的己方棋子并尝试走动。
                    var candidates = $('.' + this.camp + '.discovered:not(.empty)').get();
                    var targets = $('.discovered:not(.' + this.camp + ')').get();
                    var validMovements = [];
                    for (var i = 0; i < candidates.length; i++) {
                        var candMami = $(candidates[i]);
                        var candCell = getCellFromMami(candMami);
                        for (var i = 0; i < targets.length; i++) {
                            var tarMami = $(targets[i]);
                            var tarCell = getCellFromMami(tarMami);
                            if (candCell.canMoveTo(tarCell)) {
                                validMovements.push({pieceMami:candMami, targetMami:tarMami});
                            }
                        }
                    }
                    if (validMovements.length > 0) {
                        var mm = validMovements[0];
                        var piece = getCellFromMami(mm.pieceMami);
                        console.log('电脑的' + piece.name + '走了一步');
                        var target = getCellFromMami(mm.targetMami);
                        piece.moveTo(target);
                        updateMamiForCell(mm.pieceMami, piece);
                        updateMamiForCell(mm.targetMami, target);
                        return;
                    }

                    // 走动失败，随机（或有选择的，依据难度不同）翻开棋子。
                    var undiscovered = $('.cell:not(.discovered)').get();
                    if (undiscovered.length > 0) {
                        var toBeDiscoveredMami = $(undiscovered[randomInt(undiscovered.length)]);
                        var toBeDiscovered = getCellFromMami(toBeDiscoveredMami);
                        console.log('电脑翻开了 ' + toBeDiscovered.camp + ' ' + toBeDiscovered.name);
                        toBeDiscovered.hidden = false;
                        updateMamiForCell(toBeDiscoveredMami, toBeDiscovered);
                        return;
                    }

                    // 无可用下一步，则检测是否输局或 Pass 一步。
                    var restPieces = $('.discovered.' + this.camp).get();
                    var restEnemies = $('.discovered.' + camper.getEnemy(this.camp));
                    if (restPieces.length == 0 && restEnemies.length > 0) {
                        console.log('电脑认输');
                    } else {
                        console.log('电脑 Pass 一步');
                    }
                },
            };

            var humanPlayer = {
                selectedAlly: undefined,
                camp: undefined,
                tryMovePiece: function(targetMami) {
                    var selected = getCellFromMami(this.selectedAlly);
                    var targetCell = getCellFromMami(targetMami);
                    if (selected.canMoveTo(targetCell)) {
                        selected.moveTo(targetCell);
                        updateMamiForCell(this.selectedAlly, selected);
                        updateMamiForCell(targetMami, targetCell);
                        this.selectedAlly = undefined;
                        aiPlayer.play();
                    } else {
                        console.log('不能这么走，你要去学一学中国象棋基本规则。');
                    }
                },
                play: function(e) {
                    var clicked = $(e.currentTarget);
                    var cell = getCellFromMami(clicked);

                    if (this.selectedAlly == undefined) {
                        if (cell.name == EMPTY_NAME) {
                            console.log('点击空地。');
                        } else {
                            if (cell.hidden) {
                                console.log('翻开一颗 ' + cell.camp + ' 棋子。');

                                if (this.camp == undefined) {
                                    camper.assignCamp(cell.camp, this, aiPlayer);
                                }
                                cell.hidden = false;
                                clicked.addClass('discovered ' + cell.camp).text(cell.name);
                                aiPlayer.play();
                            } else {
                                if (this.camp == cell.camp) {
                                    console.log('选择一颗己方 ' + cell.camp + ' 棋子。');
                                    clicked.addClass('selected');
                                    this.selectedAlly = clicked;
                                } else {
                                    console.log('敌方棋子，无法选择。');
                                }
                            }
                        }
                    } else {
                        if (cell.name == EMPTY_NAME) {
                            this.tryMovePiece(clicked);
                        } else {
                            if (cell.hidden) {
                                console.log('要翻开棋子，请取消当前选择的棋子。');
                                return;
                            }
                            if (cell.camp == this.camp) {
                                $('.cell').removeClass('selected');
                                if (this.selectedAlly.get(0) == clicked.get(0)) {
                                    console.log('取消选择。');
                                    this.selectedAlly = undefined;
                                } else {
                                    console.log('切换选择。');
                                    clicked.addClass('selected');
                                    this.selectedAlly = clicked;
                                }
                            } else {
                                this.tryMovePiece(clicked);
                            }
                        }
                    }
                },
            };

            $('.cell').click(function(e){
                humanPlayer.play(e);
            });
            $('.cell').each(function(i, o){
                var jqMami = $(o);
                updateMamiForCell(jqMami, getCellFromMami(jqMami));
            });
        });
    </script>
  </head>
  <body>
    <h1><%= title %></h1>
    <p>欢迎赏玩<%= title %></p>
	<div id="board">
	<% for (var i = 0; i < rowsCount; i++) { %>
		<% for (var j = 0; j < columnsCount; j++) { %>
			<div class="cell" style="width:<%=cellSize%>px;height:<%=cellSize%>px;top:<%=i*cellSize%>px;left:<%=j*cellSize%>px;">
			</div>
		<% } %>
		<br>
	<% } %>
	</div>
  </body>
</html>
